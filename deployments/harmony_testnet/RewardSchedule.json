{
  "address": "0x243FB0a5bD826Ddb0d6D7d4f84137D77F8e4f78a",
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "BLOCKS_PER_WEEK",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "name": "FATE_PER_BLOCK",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "getFateAtIndex",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_startBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_fromBlock",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_toBlock",
          "type": "uint256"
        }
      ],
      "name": "getFatePerBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rewardsNumberOfWeeks",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xda7927e6f175e85b336105d5feb1c634ee67608f68b0394c65b3e3ba3881d3f4",
  "receipt": {
    "to": null,
    "from": "0xd45d5d7CAF24b4DE1Eab6431E160891DaAb28341",
    "contractAddress": "0x243FB0a5bD826Ddb0d6D7d4f84137D77F8e4f78a",
    "transactionIndex": 0,
    "gasUsed": "557439",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x23354bb3c6c4cece9c127cd8c1ff08b863fdc96068bdad7f164e613292743100",
    "transactionHash": "0xda7927e6f175e85b336105d5feb1c634ee67608f68b0394c65b3e3ba3881d3f4",
    "logs": [],
    "blockNumber": 14043533,
    "cumulativeGasUsed": "557439",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "solcInputHash": "067b054adfd077c1fce1552f5f448c93",
  "metadata": "{\"compiler\":{\"version\":\"0.6.12+commit.27d51765\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"BLOCKS_PER_WEEK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FATE_PER_BLOCK\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getFateAtIndex\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_startBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_fromBlock\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_toBlock\",\"type\":\"uint256\"}],\"name\":\"getFatePerBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardsNumberOfWeeks\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getFatePerBlock(uint256,uint256,uint256)\":{\"notice\":\"returns the average amount of FATE earned per block over any block period. If spanned over multiple weeks, a weighted average is calculated. Both _fromBlock and _toBlock are inclusive\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/fatex/RewardSchedule.sol\":\"RewardSchedule\"},\"evmVersion\":\"istanbul\",\"libraries\":{\"__CACHE_BREAKER__\":\"0x00000000d41867734bbee4c6863d9255b2b06ac1\"},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":10000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/math/SafeMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity >=0.6.0 <0.8.0;\\n\\n/**\\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\\n * checks.\\n *\\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\\n * in bugs, because programmers usually assume that an overflow raises an\\n * error, which is the standard behavior in high level programming languages.\\n * `SafeMath` restores this intuition by reverting the transaction when an\\n * operation overflows.\\n *\\n * Using this library instead of the unchecked operations eliminates an entire\\n * class of bugs, so it's recommended to use it always.\\n */\\nlibrary SafeMath {\\n    /**\\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        uint256 c = a + b;\\n        if (c < a) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the substraction of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b > a) return (false, 0);\\n        return (true, a - b);\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\\n        // benefit is lost if 'b' is also tested.\\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\\n        if (a == 0) return (true, 0);\\n        uint256 c = a * b;\\n        if (c / a != b) return (false, 0);\\n        return (true, c);\\n    }\\n\\n    /**\\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a / b);\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\\n        if (b == 0) return (false, 0);\\n        return (true, a % b);\\n    }\\n\\n    /**\\n     * @dev Returns the addition of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `+` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Addition cannot overflow.\\n     */\\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\\n        uint256 c = a + b;\\n        require(c >= a, \\\"SafeMath: addition overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting on\\n     * overflow (when the result is negative).\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b <= a, \\\"SafeMath: subtraction overflow\\\");\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the multiplication of two unsigned integers, reverting on\\n     * overflow.\\n     *\\n     * Counterpart to Solidity's `*` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Multiplication cannot overflow.\\n     */\\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\\n        if (a == 0) return 0;\\n        uint256 c = a * b;\\n        require(c / a == b, \\\"SafeMath: multiplication overflow\\\");\\n        return c;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: division by zero\\\");\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting when dividing by zero.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\\n        require(b > 0, \\\"SafeMath: modulo by zero\\\");\\n        return a % b;\\n    }\\n\\n    /**\\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\\n     * overflow (when the result is negative).\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {trySub}.\\n     *\\n     * Counterpart to Solidity's `-` operator.\\n     *\\n     * Requirements:\\n     *\\n     * - Subtraction cannot overflow.\\n     */\\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b <= a, errorMessage);\\n        return a - b;\\n    }\\n\\n    /**\\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\\n     * division by zero. The result is rounded towards zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryDiv}.\\n     *\\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\\n     * uses an invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a / b;\\n    }\\n\\n    /**\\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\\n     * reverting with custom message when dividing by zero.\\n     *\\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\\n     * message unnecessarily. For custom revert reasons use {tryMod}.\\n     *\\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\\n     * invalid opcode to revert (consuming all remaining gas).\\n     *\\n     * Requirements:\\n     *\\n     * - The divisor cannot be zero.\\n     */\\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\\n        require(b > 0, errorMessage);\\n        return a % b;\\n    }\\n}\\n\",\"keccak256\":\"0xcc78a17dd88fa5a2edc60c8489e2f405c0913b377216a5b26b35656b2d0dab52\",\"license\":\"MIT\"},\"contracts/fatex/RewardSchedule.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.6.12;\\n\\nimport \\\"@openzeppelin/contracts/math/SafeMath.sol\\\";\\n\\ncontract RewardSchedule {\\n    using SafeMath for uint;\\n\\n    // This is the emission schedule for each block for a given week\\n    uint[72] public FATE_PER_BLOCK = [\\n    36.00e18,\\n    36.51e18,\\n    37.02e18,\\n    37.54e18,\\n    38.06e18,\\n    38.60e18,\\n    39.14e18,\\n    39.69e18,\\n    40.24e18,\\n    40.81e18,\\n    41.38e18,\\n    41.96e18,\\n    42.55e18,\\n    72.00e18\\n    ];\\n\\n    // 30 blocks per minute, 60 minutes per hour, 24 hours per day, 7 days per week\\n    uint public constant BLOCKS_PER_WEEK = 30 * 60 * 24 * 7;\\n\\n    constructor() public {\\n    }\\n\\n    function rewardsNumberOfWeeks() external view returns (uint) {\\n        return FATE_PER_BLOCK.length;\\n    }\\n\\n    function getFateAtIndex(uint index) public view returns (uint) {\\n        if (index < 13) {\\n            // vesting occurs at an 80/20 rate for the first 13 weeks\\n            return FATE_PER_BLOCK[index] * 2 / 10;\\n        } else {\\n            return FATE_PER_BLOCK[index];\\n        }\\n    }\\n\\n    /// @notice returns the average amount of FATE earned per block over any block period. If spanned over multiple\\n    /// weeks, a weighted average is calculated. Both _fromBlock and _toBlock are inclusive\\n    function getFatePerBlock(\\n        uint _startBlock,\\n        uint _fromBlock,\\n        uint _toBlock\\n    )\\n    external\\n    view\\n    returns (uint) {\\n        if (_startBlock > _toBlock || _fromBlock == _toBlock) {\\n            return 0;\\n        }\\n        if (_fromBlock < _startBlock) {\\n            _fromBlock = _startBlock;\\n        }\\n\\n        require(\\n            _fromBlock <= _toBlock,\\n            \\\"EmissionSchedule::getFatePerBlock: INVALID_RANGE\\\"\\n        );\\n\\n        uint endBlockExclusive = _startBlock + (FATE_PER_BLOCK.length * BLOCKS_PER_WEEK);\\n\\n        if (_fromBlock >= endBlockExclusive) {\\n            return 0;\\n        }\\n\\n        if (_toBlock >= endBlockExclusive) {\\n            _toBlock = endBlockExclusive - 1;\\n        }\\n\\n        uint fromIndex = (_fromBlock - _startBlock) / BLOCKS_PER_WEEK;\\n        uint toIndex = (_toBlock - _startBlock) / BLOCKS_PER_WEEK;\\n\\n        if (fromIndex < toIndex) {\\n            uint points = BLOCKS_PER_WEEK - ((_fromBlock - _startBlock) % BLOCKS_PER_WEEK);\\n            uint fatePerBlock = points * getFateAtIndex(fromIndex);\\n\\n            for (uint i = fromIndex + 1; i < toIndex; i++) {\\n                fatePerBlock = fatePerBlock + (BLOCKS_PER_WEEK * getFateAtIndex(i));\\n            }\\n\\n            points = (_toBlock - _startBlock) % BLOCKS_PER_WEEK;\\n            fatePerBlock = fatePerBlock + (points * getFateAtIndex(toIndex));\\n\\n            return fatePerBlock / (_toBlock - _fromBlock);\\n        } else {\\n            // indices are the same\\n            assert(fromIndex == toIndex);\\n            return getFateAtIndex(fromIndex) * (_toBlock - _fromBlock);\\n        }\\n    }\\n\\n}\\n\",\"keccak256\":\"0x8ff85210c19445858d367b15f3f04e6347a8cb0b0603b7ecc596ad34ef83c173\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6102406040526801f399b1438a10000060809081526801faad938fcd83000060a052680201c175dc10f6000060c052680208f8df1ac42a000060e052680210304859775e000061010052680217aebf7d0a1400006101205268021f2d36a09cca000061014052680226cf34b69f4100006101605268022e7132cca1b80000610180526802365a3ec783b100006101a05268023e434ac265aa00006101c0526802464fddafb76400006101e05268024e7ff78f78df0000610200526803e733628714200000610220526100d590600090600e6100e8565b503480156100e257600080fd5b50610146565b8260488101928215610121579160200282015b8281111561012157825182906001600160481b03169055916020019190600101906100fb565b5061012d929150610131565b5090565b5b8082111561012d5760008155600101610132565b61030f806101556000396000f3fe608060405234801561001057600080fd5b50600436106100675760003560e01c8063c0f34ddc11610050578063c0f34ddc146100b8578063fb4c0e49146100c0578063fc47e209146100e957610067565b806344ea9de51461006c5780639d33918e1461009b575b600080fd5b6100896004803603602081101561008257600080fd5b50356100f1565b60408051918252519081900360200190f35b610089600480360360208110156100b157600080fd5b5035610105565b61008961014a565b610089600480360360608110156100d657600080fd5b508035906020810135906040013561014f565b6100896102a2565b600081604881106100fe57fe5b0154905081565b6000600d82101561013357600a6000836048811061011f57fe5b01546002028161012b57fe5b049050610145565b6000826048811061014057fe5b015490505b919050565b604890565b60008184118061015e57508183145b1561016b5750600061029b565b83831015610177578392505b818311156101d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260308152602001806102aa6030913960400191505060405180910390fd5b63014c3a0084018084106101e857600091505061029b565b8083106101f6576001810392505b62049d4085850381900490868503048082101561027f5762049d408787038190069003600061022484610105565b82029050600184015b838110156102505761023e81610105565b62049d4002919091019060010161022d565b5062049d4089880306915061026483610105565b820201878703818161027257fe5b049550505050505061029b565b80821461028857fe5b85850361029483610105565b0293505050505b9392505050565b62049d408156fe456d697373696f6e5363686564756c653a3a67657446617465506572426c6f636b3a20494e56414c49445f52414e4745a264697066735822122019644234945c950e173856069f3fdbceadf363f531ca99bdf58825d79638171164736f6c634300060c0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100675760003560e01c8063c0f34ddc11610050578063c0f34ddc146100b8578063fb4c0e49146100c0578063fc47e209146100e957610067565b806344ea9de51461006c5780639d33918e1461009b575b600080fd5b6100896004803603602081101561008257600080fd5b50356100f1565b60408051918252519081900360200190f35b610089600480360360208110156100b157600080fd5b5035610105565b61008961014a565b610089600480360360608110156100d657600080fd5b508035906020810135906040013561014f565b6100896102a2565b600081604881106100fe57fe5b0154905081565b6000600d82101561013357600a6000836048811061011f57fe5b01546002028161012b57fe5b049050610145565b6000826048811061014057fe5b015490505b919050565b604890565b60008184118061015e57508183145b1561016b5750600061029b565b83831015610177578392505b818311156101d0576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260308152602001806102aa6030913960400191505060405180910390fd5b63014c3a0084018084106101e857600091505061029b565b8083106101f6576001810392505b62049d4085850381900490868503048082101561027f5762049d408787038190069003600061022484610105565b82029050600184015b838110156102505761023e81610105565b62049d4002919091019060010161022d565b5062049d4089880306915061026483610105565b820201878703818161027257fe5b049550505050505061029b565b80821461028857fe5b85850361029483610105565b0293505050505b9392505050565b62049d408156fe456d697373696f6e5363686564756c653a3a67657446617465506572426c6f636b3a20494e56414c49445f52414e4745a264697066735822122019644234945c950e173856069f3fdbceadf363f531ca99bdf58825d79638171164736f6c634300060c0033",
  "devdoc": {
    "kind": "dev",
    "methods": {},
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getFatePerBlock(uint256,uint256,uint256)": {
        "notice": "returns the average amount of FATE earned per block over any block period. If spanned over multiple weeks, a weighted average is calculated. Both _fromBlock and _toBlock are inclusive"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 8753,
        "contract": "contracts/fatex/RewardSchedule.sol:RewardSchedule",
        "label": "FATE_PER_BLOCK",
        "offset": 0,
        "slot": "0",
        "type": "t_array(t_uint256)72_storage"
      }
    ],
    "types": {
      "t_array(t_uint256)72_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[72]",
        "numberOfBytes": "2304"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}